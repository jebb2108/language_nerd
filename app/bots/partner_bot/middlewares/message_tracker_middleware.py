import asyncio
import logging
from collections import defaultdict
from typing import Callable, Any, Dict, TYPE_CHECKING
from aiogram import BaseMiddleware
from aiogram.types import CallbackQuery, Message

from app.dependencies import get_redis, get_redis_client
from app.models import SentMessage

from config import LOG_CONFIG, config

if TYPE_CHECKING:
    from aiogram import Bot

logging.basicConfig(**LOG_CONFIG)
logger = logging.getLogger(name="message_tracker_middleware")

class MessageTrackerMiddleware(BaseMiddleware):
    def __init__(self, bot: "Bot"):
        self.bot = bot
        self.edited_messages = defaultdict(list)
        self.search_messages = defaultdict(list)
        self.active_searches = defaultdict(bool)

    async def __call__(
        self, handler: Callable, event: Any, data: Dict[str, Any]
    ) -> Any:

        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –í–•–û–î–Ø–©–ò–ï —Å–æ–±—ã—Ç–∏—è –î–û handler
        if isinstance(event, CallbackQuery):
            # await self.track_callback(event)
            pass

        # –í—ã–∑—ã–≤–∞–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫
        result = await handler(event, data)

        if isinstance(result, Message):
            await self.track_message(result)

        # –î–ª—è –ø–µ—Ä–µ—Ö–≤–∞—Ç–∞ –ò–°–•–û–î–Ø–©–ò–• —Å–æ–æ–±—â–µ–Ω–∏–π –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ç–¥–µ–ª—å–Ω—É—é —Å—Ç—Ä–∞—Ç–µ–≥–∏—é
        # –°–æ–∑–¥–∞–µ–º –∑–∞–¥–∞—á—É –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø–æ—Å–ª–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏
        asyncio.create_task(self._post_process(event, data))

        return result


    async def track_message(self, message: Message):
        """–û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è"""
        try:
            chat_id = message.chat.id
            message_id = message.message_id



            message_info = SentMessage(
                message_id=message_id,
                chat_id=chat_id,
                text=message.text or message.caption,
            )

            # –ï—Å–ª–∏ —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –Ω–∞—á–∞–ª–µ –ø–æ–∏—Å–∫–∞
            if message_info.text.startswith("üîç"):
                await self.start_search(chat_id, message_id, message_info)

        except Exception as e:
            logger.error(f"Error in track_message: {e}")






    async def _post_process(self, event: Any, data: Dict[str, Any]):
        """–ü–æ—Å—Ç-–æ–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ö–µ–Ω–¥–ª–µ—Ä–∞"""

        # –î–∞–µ–º –≤—Ä–µ–º—è –Ω–∞ –æ—Ç–ø—Ä–∞–≤–∫—É —Å–æ–æ–±—â–µ–Ω–∏–π
        await asyncio.sleep(0.5)

        print(data)


        if isinstance(event, Message):
            await self.check_webapp_buttons(event)





    async def _check_chat_state(self, chat_id: int, bot: "Bot"):
        """–ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —á–∞—Ç–∞ –∏ –æ–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è"""
        if chat_id in self.search_messages:
            # –í–∞—à–∞ –ª–æ–≥–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ TTL –∏ WebApp –∫–Ω–æ–ø–æ–∫
            redis = await get_redis()
            key = f"search_message:{chat_id}"
            if not await redis.exists(key):
                await self.cleanup_previous_searches()
        logger.warning(f"There is this active search going on: {self.search_messages[chat_id]}")



    async def start_search(self, chat_id: int, message_id: int, message_info: "SentMessage") -> None:
        """–ù–∞—á–∏–Ω–∞–µ–º –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –ø–æ–∏—Å–∫–∞"""
        try:
            redis = await get_redis()
            key = f"search_message:{message_id}"
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ Redis —Å TTL
            await redis.save_sent_message(
                key,
                message_info,
                config.WAIT_TIMER
            )

            # –û—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ–∏—Å–∫–∞ –¥–ª—è —ç—Ç–æ–≥–æ —á–∞—Ç–∞
            await self.cleanup_previous_searches(chat_id, message_id)

            # –î–æ–±–∞–≤–ª—è–µ–º –≤ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
            self.search_messages[chat_id].append(message_id)
            self.active_searches[chat_id] = True

            logger.info(f"Started tracking search: chat={chat_id}, message={message_id}")

        except Exception as e:
            logger.error(f"Error in start_search_handler: {e}")



    async def finish_search(self, message: Message):
        """–ó–∞–≤–µ—Ä—à–∞–µ–º –ø–æ–∏—Å–∫ –∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è"""
        redis_client = await get_redis_client()
        q = await redis_client.lrange("sent_messages", 0, -1)
        q = [msg.decode() for msg in q]
        tp = config.SEARCH_COMPLETED_MESSAGE_TYPE
        web_appeeared: dict = next([msg for msg in q if msg.get("message_type") == tp], None)
        if web_appeeared:
            chat_id = web_appeeared.get("chat_id")
            msg_id = web_appeeared.get("message_id")
            self.




        # for indx, message_id in enumerate(queue, 0):
        #     mid = message_id.decode()
        #     key = f"search_message:{mid}"
        #     m_data: dict = await redis_client.hgetall(key)
        #     if m_data.get("web_info") == 1:






    async def cleanup_previous_searches(self, chat_id: int, curr_mid):
        """–û—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ–∏—Å–∫–∞"""
        try:
            if chat_id in self.search_messages and self.search_messages[chat_id]:
                for message_id in self.search_messages[chat_id]:
                    # –†—Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤–º–µ—Å—Ç–æ —É–¥–∞–ª–µ–Ω–∏—è,
                    # —á—Ç–æ–±—ã —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é –ø–µ—Ä–µ–ø–∏—Å–∫–∏
                    if message_id != curr_mid:

                        await self.bot.delete_message(chat_id, message_id)
                        self.search_messages[chat_id].remove(message_id)

                self.active_searches[chat_id] = False

        except Exception as e:
            logger.error(f"Error in cleanup_previous_searches: {e}")


    async def check_webapp_buttons(self, message: Message) -> None:
        """–ü—Ä–æ–≤–µ—Ä—è–µ–º WebApp –∫–Ω–æ–ø–∫–∏ (–ø–∞—Ä—Ç–Ω–µ—Ä –Ω–∞–π–¥–µ–Ω)"""

        chat_id = message.chat.id

        if not self.active_searches.get(chat_id):
            return

        has_webapp = False
        for row in message.reply_markup.inline_keyboard:
            for button in row:
                if hasattr(button, 'web_app') and button.web_app:
                    has_webapp = True
                    break
            if has_webapp:
                break

        if has_webapp:
            # –ó–∞–≤–µ—Ä—à–∞–µ–º –ø–æ–∏—Å–∫
            await self.finish_search(message)
